Given cs (order comparison at start of line):
  void f() {
    if (i
    < LongFunctionName())
  }

Execute:
  normal! 2jf<
  AssertEqual 'csOpSymbols', SyntaxAt()


Given cs (order comparison at end of line):
  void f() {
    if (i <
    LongFunctionName())
  }

Execute:
  normal! jf<
  AssertEqual 'csOpSymbols', SyntaxAt()


Given cs (order comparison with whitespace):
  void f() {
    if (7 < 8)
  }

Execute:
  normal! jf<
  AssertEqual 'csOpSymbols', SyntaxAt()


Given cs (order comparison missing whitespace):
  void f() {
    if (7<8)
  }

Execute:
  normal! jf<
  AssertEqual 'csOpSymbols', SyntaxAt()


Given cs (generic function):
  void f<int>() {
    return Get<int>();
  }

Execute:
  normal! f<
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! f>
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! j0f<
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! f>
  AssertEqual 'csGenericBraces', SyntaxAt()


Given cs (generic inside generic):
  Dictionary<string,List<Image>> f() {
    return 'a' <> null;
  }

Execute:
  normal! f<
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! f<
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! f>
  AssertEqual 'csGenericBraces', SyntaxAt()
  normal! f>
  AssertEqual 'csGenericBraces', SyntaxAt()

# Keyword operators

Given cs (default operator):
  default(Dictionary<string,List<Image>>)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('default')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csDefaultOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (default operator with space before open paren):
  default (Dictionary<string,List<Image>>)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('default')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csDefaultOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (default operator with missing operand parens):
  default Dictionary<string,List<Image>>

Execute:
# TODO: Not enough context in default literal matching to match this as a
#       missing paren operator call
  AssertEqual 'csDefault',   SyntaxOf('default')

Given cs (typeof operator):
  typeof(Dictionary<string,List<Image>>)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('typeof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csTypeOfOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (typeof operator with space before open paren):
  typeof (Dictionary<string,List<Image>>)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('typeof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csTypeOfOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (typeof operator with missing operand parens):
  typeof Dictionary<string,List<Image>>

Execute:
  AssertEqual 'csKeywordOperator',   SyntaxOf('typeof')
  AssertEqual 'csMissingParenError', SyntaxAt(1, 8)

Given cs (sizeof operator):
  sizeof(byte)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('sizeof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csType',            SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (sizeof operator with space before open paren):
  sizeof (byte)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('sizeof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csType',            SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (sizeof operator with missing operand parens):
  sizeof byte

Execute:
  AssertEqual 'csKeywordOperator',   SyntaxOf('sizeof')
  AssertEqual 'csMissingParenError', SyntaxOf('b\zeyte')

Given cs (nameof operator):
  nameof(foobar)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('nameof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csNameOfOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (nameof operator with space before open paren):
  nameof (foobar)

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('nameof')
  AssertEqual 'csParens',          SyntaxOf('(')
  AssertEqual 'csNameOfOperand',   SyntaxOf('(\zs')
  AssertEqual 'csParens',          SyntaxOf(')')

Given cs (nameof operator with missing operand parens):
  nameof foobar

Execute:
  AssertEqual 'csKeywordOperator',   SyntaxOf('nameof')
  AssertEqual 'csMissingParenError', SyntaxOf('f\zeoobar')

Given cs (await operator):
  await foobar();

Execute:
  AssertEqual 'csAsyncOperator', SyntaxOf('await')

Given cs (checked operator):
  var foobar = checked(42 + 1);

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('checked')

Given cs (unchecked operator):
  var foobar = unchecked(42 + 1);

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('unchecked')

Given cs (new operator):
  var foo = new Bar();

Execute:
  AssertEqual 'csNew', SyntaxOf('new')

Given cs (stackalloc operator):
  Span<byte> foobar = stackalloc byte[42];

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('stackalloc')

Given cs (switch operator):
  var foo = bar switch { _ => 42 };

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('switch')

Given cs (delegate operator):
  Func<int> foobar = delegate (int a) { return 42; };
     Action foobar = delegate { FortyTwo(); };

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('delegate', 1)
  AssertEqual 'csKeywordOperator', SyntaxOf('delegate', 2)

Given cs (with operator):
  var foo = bar with { Baz = 42 };

Execute:
  AssertEqual 'csKeywordOperator', SyntaxOf('with')

